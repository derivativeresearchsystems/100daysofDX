---
layout: post
comments: true
title: "#28 - Avoid chattiness in REST APIs"
date: 2019-08-09 03:32:44
image: '/assets/img/day27/blog.png'
description: "Design REST APIs resource focused"
tags:
- DX 
- 100DaysDX
- Dark theme
- Readability
- Code
- Research

categories:
- DX
- 100DaysDX
twitter_text: "#28 - Avoid chattiness in REST APIs"
---

Chattines of REST APIs is one of the topic which came up in discussions with Viljami Kuosmanen about a year ago. I did not have time to put more thought on it before now. I kind of remember what Viljami said, but to make it clear what the hell that means, why develoopers (API consumers) do not like it and how it can be avoided, needed a little more thinking and exploring. 

## Chatty API

Chatty API is one that requires consumer to make tremendous (subjective matter) amount of distinct API calls to get needed information about a resource. For example if you need to collect resources for a section in web application and if API is chatty, it might force you to get needed info for each object separately. Luckily most of the REST APIs are not designed that poorly. That was just an extreme example. The chattiness is normally more subtle. 

Lets's take an example. Developer wants to get the product reviews, but API offers only GET method to list products (`/api/products/123`) and returns

```json
{
   "name": "A monkey",
   "cost", "$5000.00",
   "reviews": [
        "/api/reviews/1",
        "/api/reviews/2",
        "/api/reviews/3"
        ...
        "/api/reviews/2071"
    ]
}

```
To get the reviews for a product, developer needs to make N amount of API requests to get the reviews. N might be thousands depending of the amount of the reviews. Eh, looks like a flaw in API design and that's what it really is. You have just created prime example of a chatty API. 

## Use resource oriented approach

To avoid chattines in APIS, instead of building get and set methods in the API, you focus on resources. But regarding the example above, fix might be that API has `/api/products/{id}/reviews` endpoint. Then the consumer would get all reviews with one API call which could be limited and ordered with parameters. 

```json
{
   "name": "A monkey",
   "reviews":[
        { "id": "1", "reviewer": "Jarkko", "notes": "foobar"},
        { "id": "2", "reviewer": "Sven", "notes": "foobar"},
        { "id": "3", "reviewer": "Pirkko", "notes": "foobar"},
        { "id": "4", "reviewer": "Toni", "notes": "foobar"},
        ...
        { "id": "2071", "reviewer": "Pekka", "notes": "foobar"} 
    ]
}
```
API might take advantage of the partial response style too. ```/api/products/123/reviews?fields=notes```. Then the consumer gets just the information s/he needs. 

```json
{
   "name": "A monkey",
   "reviews":[
        { "notes": "foobar"},
        { "notes": "foobar"},
        { "notes": "foobar"},
        { "notes": "foobar"},
        ...
        { "notes": "foobar"} 
    ]
}
```

HATEOAS may be the purists’ choice, but it does come with a certain amount of baggage. It makes an API more complex to implement while tending to bloat the response. It can give rise to a more “chatty” style of integration as clients navigate through links rather than jumping straight in to the resources they need. 

Offering links to next set of responses (if paginated) is the common way to implement HATEOAS idea partially. Idea is that you offer the consumer ready constructed API endpoint calls in the response in addition to actual content data. 

```json
{
   "name": "A monkey",
   "reviews":[
        { "notes": "foobar"},
        { "notes": "foobar"},
        { "notes": "foobar"},
        { "notes": "foobar"},
        ...
        { "notes": "foobar"} 
    ],
    "links": [
      {
          "rel": "self",
          "href": "https://host.com/api/products/123/reviews?fields=notes&limit=30",
      },
      {
          "rel": "first",
          "href": "https://host.com/api/products/123/reviews?fields=notes&limit=30?from=0",
      },
      {
          "rel": "next",
          "href": "https://host.com/api/products/123/reviews?fields=notes&limit=30&from=30",
      }
  ]
}
```


## If you don't know in design phase...

Of course you can't know every use case for the API in design phase. But you should know the most common use cases and fulfill the needs of those. You can follow how your API is used mostly, ask feedback and use cases from the API consumers and so on. Based on that feedback you add new endpoints to offer needed data with less amount of API calls to reduce chattiness and at the same time increase the developer experience. 